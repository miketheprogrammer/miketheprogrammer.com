{
  "name": "map-reduce",
  "description": "map-reduce on leveldb",
  "version": "3.1.5",
  "homepage": "https://github.com/dominictarr/map-reduce",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/map-reduce.git"
  },
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "http://bit.ly/dominictarr"
  },
  "dependencies": {
    "level-trigger": "~1.1.0"
  },
  "devDependencies": {
    "level-sublevel": "~4.6",
    "through": "~1.1.1",
    "levelup": "~0.6",
    "rimraf": "~2.0.2",
    "pad": "0.0.3",
    "macgyver": "~1.9",
    "optimist": "0.3.5",
    "tape": "~0.2.2"
  },
  "scripts": {
    "test": "set -e; for t in test/*.js; do node $t; done"
  },
  "readme": "# Map Reduce for leveldb (via levelup)\n\nIncremental map-reduces and real-time results.\n\n## Waat?\n\nAn \"incremental map reduce\" means when you update one key,\nonly a relevant protion of the data needs to be recalculated.\n\n\"real-time results\" means that you can listen to the database,\nand recieve change notifications on the fly! a la \n[level-live-stream](https://github.com/dominictarr/level-live-stream)\n\n## Example\n\n### create a simple map-reduce\n\n``` js\nvar LevelUp   = require('levelup')\nvar SubLevel  = require('level-sublevel')\nvar MapReduce = require('map-reduce')\n\nvar db = SubLevel(LevelUp(file))\n\nvar mapDb = \n  MapReduce(\n    db, //the parent db\n    'example',  //name.\n    function (key, value, emit) {\n      //perform some mapping.\n      var obj = JSON.parse(value)\n      //emit(key, value)\n      //key may be an array of strings. \n      //value must be a string or buffer.\n      emit(['all', obj.group], ''+obj.lines.length)\n    },\n    function (acc, value, key) {\n      //reduce little into big\n      //must return a string or buffer.\n      return ''+(Number(acc) + Number(value))\n    },\n    //pass in the initial value for the reduce.\n    //*must* be a string or buffer.\n    '0'\n  })\n})\n\n```\n\n`map-reduce` uses [level-trigger](https://github.com/dominictarr/level-trigger) to make map reduces durable.\n\n\n### querying results.\n\n``` js\n  //get all the results in a specific group\n  //start:[...] implies end:.. to be the end of that group.\n  mapDb.creatReadStream({range: ['all', group]}) \n\n  //get all the results in under a group.\n  mapDb.creatReadStream({range: ['all', true]}) \n\n  //get all the top level \n  mapDb.creatReadStream({range: [true]})\n\n```\n\n<!--\nby default, the stream will stay open, and continue to give you the latest results.\nThis may be disabled by passing `{tail:false}`. \nThe stream responds correctly to `stream.pause()` and `stream.resume()`\n\n``` js\n  db.mapReduce.view(viewName, {start: ['all', true], tail: false}) \n```\n-->\n### complex aggregations\n\nmap-reduce with multiple levels of aggregation.\n\nsuppose we are building a database of all the street-food in the world.\nthe data looks like this:\n\n``` js\n{\n  country: USA | Germany | Cambodia, etc...\n  state:   CA | NY | '', etc...\n  city: Oakland | New York | Berlin | Phnom Penh, etc...\n  type: taco | chili-dog | doner | noodles, etc...\n}\n```\n\nWe will aggregate to counts per-region, that look like this:\n\n``` js\n//say: under the key USA\n{\n  'taco': 23497,\n  'chili-dog': 5643,\n  etc...\n}\n```\n\nfirst we'll map the raw data to `([country, state, city],type)` tuples.\nthen we'll count up all the instances of a particular type in that region!\n\n``` js\n\nvar LevelUp   = require('levelup')\nvar SubLevel  = require('level-sublevel')\nvar MapReduce = require('map-reduce')\n\nvar db = SubLevel(LevelUp(file))\nvar mapDb = \n  MapReduce(\n    db,\n    'streetfood',\n    function (key, value, emit) {\n      //perform some mapping.\n      var obj = JSON.parse(value)\n      //emit(key, value)\n      //key may be an array of strings. \n      //value must be a string or buffer.\n      emit(\n        [obj.country, obj.state || '', obj.city],\n        //notice that we are just returning a string.\n        JSON.stringify(obj.type)\n      )\n    },\n    function (acc, value) {\n      acc = JSON.parse(acc)\n      value = JSON.parse(value)\n      //check if this is top level data, like 'taco' or 'noodle'\n      if('string' === typeof value) {\n        //increment by one (remember to set as a number if it was undefined)\n        acc[value] = (acc[value] || 0) ++\n        return JSON.stringify(acc)\n      }\n      //if we get to here, we are combining two aggregates.\n      //say, all the cities in a state, or all the countries in the world.\n      //value and acc will both be objects {taco: number, doner: number2, etc...}\n\n      for(var type in value) {\n        //add the counts for each type together...\n        //remembering to check that it is set as a value...\n        acc[type] = (acc[type] || 0) + value[type]\n      }\n      //stringify the object, so that it can be written to disk!\n      return JSON.stringify(acc)\n    },\n    '{}')\n```\n\nthen query it like this:\n\n``` js\nmapDb.createReadStream({range: ['USA', 'CA', true]})\n  .pipe(...)\n```\n\n<!---\nTODO: add live-streams, and reinstate this documentation\n``` js\n//pass tail: false, because new streetfood doesn't appear that often...\n\nmapDb.createReadStream({range: ['USA', 'CA', true]})\n  .pipe(...)\n//or get the streetfood counts for each state. \n//we want to know about realtime changes this time.\nmapDb.createReadStream({range: ['USA', true]})\n\n```\n-->\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/dominictarr/map-reduce/issues"
  },
  "_id": "map-reduce@3.1.5",
  "dist": {
    "shasum": "5cf9c5802449604eed694c8b419be54d4e29b133"
  },
  "_from": "map-reduce@~3.1.2",
  "_resolved": "https://registry.npmjs.org/map-reduce/-/map-reduce-3.1.5.tgz"
}
