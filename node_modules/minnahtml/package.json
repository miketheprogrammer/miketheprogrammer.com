{
  "name": "minnahtml",
  "version": "0.3.7",
  "author": {
    "name": "Robee Shepherd",
    "email": "robee_git@robeesworld.com"
  },
  "description": "An async aware HTML object library primarily aimed at Node.js users",
  "contributors": [
    {
      "name": "Robee Shepherd",
      "email": "robee_git@robeesworld.com"
    }
  ],
  "main": "./lib/index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/RobeeeJay/MinnaHTML.js.git"
  },
  "keywords": [
    "html",
    "oop",
    "xml",
    "www",
    "framework"
  ],
  "license": "GPL",
  "engine": {
    "node": ">=0.4"
  },
  "readme": "MinnaHTML.js\n============\n\nAn async aware HTML object library primarily aimed at Node.js users\n\n\n\nLicense\n=======\n\nThis library is released under the GNU General Public License v3:\nhttp://www.gnu.org/copyleft/gpl.html\n\n\n\nTo Do\n=====\n\nAdd a lot more documentation\nAdd remaining missing HTML objects\n\n\n\nAbout the Author\n================\n\nMinnaHTML was written by Robee Shepherd, after some 13 years of developing web applications. Having been coding since the age of 10, starting with BASIC and then Z80 assembley language on the ZX-81 and ZX Spectrum, Robee has journeyed through the hell of 16-bit DOS and Windows development in C/C++ where pointers regularly wrapped around, through 32-bit Windows, the early days of ASP and finally to the modern joyous world of Node.JS.\n\nThat's quite a lot of programming experience, with so little to show for it.\n\n\n\nWhat's It Do?\n=============\n\nMinnaHTML is a very easy to grasp, simple object oriented library for the quick generation of webpages with as little or as much object oriented code as the user desires.\n\nAs importantly, it is async aware, which means you can use it to pass off a DIV object to a function with a callback, and not worry about delivering an incomplete HTML file to the end client.\n\n\n\nQuick Walkthrough\n=================\n\nMinnaHTML objects map directly to HTML objects, in an obvious and simple to remember syntax:\n\n\tnew mh.OBJECT(parent, cid, vars, blankId)\n\n\nWhere the arguments are as follows:\n\n\tparent = a parent MinnaHTML object for this to belong to\n\tcid = an optional string representing the id of the object (eg. \"maindiv\")\n\tvars = an optional object containing any attributes you wish to add to the HTML object (eg. \"{ class: 'pretty' }\")\n\tblankId = an optional boolean for hiding the id of the object\n\n\nThat's pretty much all there is too it! Well, okay the objects have helper functions for adding/removing parents, finding child objects, iterating with functions, and so on, much like you are used to with jQuery. But more on that later.\n\n\nFirstly, the most basic example possible:\n\n\tvar objEntireWebpage = new mh.Html();\n\t\n\tobjEntireWebpage.data.content = \"<head><title>Simple Webpage</title></head>\";\n\tobjEntireWebpage.data.content += \"<body><p>Very little to see here!</p></body>\";\n\n\nNow, if you call objEntireWebpage.generateHtml() it would return the following as a string:\n\n\t<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n\t<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n\t <head><title>Simple Webpage</title></head><body><p>Very little to see here!</p></body>\n\t</html>\n\n\nLet's rewrite it using more objects!\n\n\tvar objEntireWebpage = new mh.Html();\n\t\n\tvar objHeadSection = new mh.Head(objEntireWebpage);\n\tnew mh.Title(objHeadSection).data.content = \"Simple Webpage\";\n\t\n\tvar objBodySection = new mh.Body(objEntireWebpage);\n\tnew mh.Paragraph(objBodySection).data.content = \"Very little to see here!\";\n\n\nCalling objEntireWebpage.generateHtml() would return the following as a string, which is pretty much the same as we had before but with prettier easy to read auto-indenting:\n\n\t<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n\t<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n\t <head>\n\t  <title>\n\t   Simple Webpage\n\t  </title>\n\t </head>\n\t <body>\n\t  <p>\n\t   Very little to see here!\n\t  </p>\n\t </body>\n\t</html>\n\n\nHopefully the smarter of you are already starting to see the possibilities of this method for generating pages. Because they are represented in an efficient object hierarchy, you can start to do things to pages in a much more flexible way than having one big template that you search and replace on.\n\nGot a standard bit of code that pulls a twitter feed and shoves it in a DIV? Stick it in a function which gets passed a mh.Div object and away it goes. It doesn't have to know anything other than to fill that object with its data, the context of that data can switch between thrown in a full page, to delivered via AJAX to a browser client.\n\nFurthermore, if you build webapps using an OOP design, MinnaHTML slots in perfectly into this scenario. An object near the top of your tree can create objects that represent the basics of your webpages, and derived objects can easily add to the content as and when required.\n\n\nOne little thing to note, you can reference objects by their ID, and any property of that object (excluding data, which is a special property you shouldn't mess with without understanding), will become a parameter of that object. Here are some quick example and the HTML it would generate:\n\n\tvar objDiv = new mh.Div(null, \"dog\", { class: \"notacat\", onclick: \"alert('Woof')\");\n\tnew mh.Paragraph(objDiv, \"cat\");\n\tobjDiv.cat.data.content = \"I'm not a dog!\";\n\t\n\t<div class=\"notacat\" onclick=\"alert('Woof')\">\n\t\t<p>\n\t\t\tI'm not a dog!\n\t\t</p>\n\t</div>\n\n\nIf you haven't worked it out already, object.data.content can be set to contain a string which becomes the content of the HTML object. Note that setting this to a string changes how children of this object behave. Setting this string trumps children, and the only way children of this object will appear is via a search and replace on text in this string that includes the format [[child_id]]. Eg.\n\n\tvar objDiv = new mh.Div();\n\tobjDiv.data.content = \"Some text [[child_dog]] surrounding a div\";\n\tvar objChild = new mh.Div(objDiv, \"dog\");\n\t\n\t<div>\n\t\tSome text <div id=\"dog\">\n\t\t</div> surrounding a div\n\t</div>\n\n\n\nAsync Ready!\n============\n\nOne thing that requires a lot of thought with Node.js, is the simple question, \"How do I ensure my document is ready before I send it?\" Well, if you use MinnaHTML then you don't have to worry too much about that, because it can handle this for you via the following object functions:\n\n\tobject.isReady()\n\tTells an object that it is unfinished and should prevent any page generation from taking place\n\t\n\tobject.notReady()\n\tTells an object that it is ready and that page generation can safely take place\n\n\tobject.whenReady(callback)\n\tWhen an object (and all its children) is safely marked as ready, calls the callback function with the generated HTML\n\n\nNow first off, all objects start off in the ready state. And calling whenReady() can result in the callback being fired immediately.\n\nWith that in mind, the following should demonstrate how this works:\n\n\tvar objEntireWebpage = new mh.Html();\n\t\n\tvar objHeadSection = new mh.Head(objEntireWebpage);\n\tnew mh.Title(objHeadSection).data.content = \"Simple Webpage\";\n\t\n\tvar objBodySection = new mh.Body(objEntireWebpage);\n\n\tobjBodySection.notReady();\n\t\n\tobjEntireWebpage.whenReady(function(strHtml) {\n\t\tconsole.log(strHtml);\n\t});\n\t\n\tsetTimeout(function() {\n\t\tnew mh.Paragraph(objBodySection).data.content = \"Very little to see here!\";\n\t\tobjBodySection.isReady();\n\t}, 3000);\n\n\nThe objBodySection object is declared not ready, because we still have to add our epic paragraph to it. For the objEntireWebpage object which all the others ultimately belong to, we tell it to call an anonymous function when it is ready, that lists the generated HTML to the console.\n\nThe setTimeout function simulates a process that might take a bit of time, or at least is asynchronous, and after 3 seconds it adds the paragraph to the body section object, and then declares that to be ready.\n\nSince in this case, declaring objBodySection as ready means the entire object tree is ready, this immediately calls the callback we passed to whenReady().\n\nThis general approach to representing the final delivered document as an object tree hierarchy, which is aware of its state of readyness, makes delivering full content pages via Node.js very easy all of a sudden.\n\nCreate a load of DIV objects, add them to your body, them not ready, make a load of async database calls to get the info you need to fill them, and when they are all ready your callback of choice is fired which can send it instantly to the client. No waiting around.\n\n\n\nThere Is More\n=============\n\nSending data to the client via AJAX? You can use a PlaceHolder object that itself generates no HTML, just to abuse it's async features, or add plain text data to it or JSON, or use it to send dynamic HTML to insert into the client.\n\nYou can iterate through objects, search for them, add and remove parents, add and remove children, ",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/RobeeeJay/MinnaHTML.js/issues"
  },
  "_id": "minnahtml@0.3.7",
  "_from": "minnahtml@"
}
